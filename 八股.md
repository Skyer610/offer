### 面向对象的三大特征是封装、继承、多态。
封装：将数据和操作数据的方法进行有机结合，隐藏对象的属性和实现细节，仅对外公开接口来和对象进行交互。
继承：可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。三种方式 private protected public
多态：用父类型别的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。实现多态，有二种方式，重写，重载。

### 重载
我们在平时写代码中会用到几个函数但是他们的实现功能相同，但是有些细节却不同。例如：交换两个数的值其中包括（int, float,char,double)这些个类型。在C语言中我们是利用不同的函数名来加以区分。这样的代码不美观而且给程序猿也带来了很多的不便。于是在C++中人们提出了用一个函数名定义多个函数，也就是所谓的函数重载。函数重载是指同一可访问区内被声明的几个具有不同参数列（参数的类型，个数，顺序不同）的同名函数，根据参数列表确定调用哪个函数，重载不关心函数返回类型。

###  简述一下虚函数和纯虚函数，以及实现原理
虚函数是C++中的一种特殊函数，其在基类中声明，可以在派生类中进行覆盖，允许使用基类的指针或引用调用派生类对象的函数。

当一个类的成员函数被声明为虚函数时，编译器会创建一个虚函数表（vtable）来存储类中的虚函数地址。每个对象都包含一个指向虚函数表的指针，这个指针被称为虚指针（vptr）。当调用虚函数时，实际调用的是虚表中的函数，而不是编译时确定的函数。

这个特性允许在运行时动态绑定函数的实现，实现多态性。多态性是面向对象编程的一个重要特性，允许以统一的方式处理不同的对象类型，并根据对象的类型调用相应的函数。

假设有一个基类Animal和两个派生类Dog和Cat，代码如下：
```c++
#include <iostream>
using namespace std;

class Animal {
public:
    virtual void makeSound() {
        cout << "Animal makes a sound." << endl;
    }
};

class Dog : public Animal {
public:
    void makeSound() {
        cout << "Dog barks." << endl;
    }
};

class Cat : public Animal {
public:
    void makeSound() {
        cout << "Cat meows." << endl;
    }
};

```
在这个示例中，Animal类中有一个虚函数makeSound()，该函数在Dog和Cat类中进行了覆盖。在这里，使用了virtual关键字来声明这个函数是虚函数。

现在，我们可以创建Animal、Dog和Cat类的对象，并使用它们的makeSound()函数。例如：
```c++
int main() {
    Animal *a1 = new Animal();
    a1->makeSound();  // Animal makes a sound.

    Dog *d1 = new Dog();
    d1->makeSound();  // Dog barks.

    Cat *c1 = new Cat();
    c1->makeSound();  // Cat meows.

    Animal *a2 = new Dog();
    a2->makeSound();  // Dog barks.

    Animal *a3 = new Cat();
    a3->makeSound();  // Cat meows.

    delete a1;
    delete d1;
    delete c1;
    delete a2;
    delete a3;

    return 0;
}

```
在这里，我们创建了Animal、Dog和Cat类的对象，并使用它们的makeSound()函数。我们还创建了Animal类型的指针a2和a3，并将它们分别指向Dog和Cat对象。然后，我们通过这些指针调用makeSound()函数。由于makeSound()函数被声明为虚函数，编译器将在运行时动态绑定相应的函数实现。

在这个示例中，我们可以看到，使用基类指针或引用调用派生类对象的函数时，会根据对象的类型调用相应的函数。这就是虚函数的多态性。


### 指针和地址有什么关系什么区别
指针和地址是密切相关的概念，它们通常被一起使用。下面是它们的关系和区别：
地址是指变量在内存中的位置，是一个数值。每个变量都有一个地址。
指针是一个==变量==，存储另一个变量的地址，可以通过解引用操作符 * 来访问所指向的变量的值。
因此，指针和地址的区别在于它们所代表的含义和使用方式不同。地址是变量在内存中的位置，而指针是一个变量，存储另一个变量的地址。指针变量可以通过解引用操作符 * 来访问所指向变量的值。
以下是一个简单的示例程序，演示了地址和指针的基本概念：
```c
#include <stdio.h>

int main() {
  int a = 10;
  int* p = &a;  // 定义指向变量 a 的指针

  printf("变量 a 的地址：%p\n", &a);
  printf("指针变量 p 的值：%p\n", p);
  printf("指针 p 所指向的变量的值：%d\n", *p);
    //变量 a 的地址：0x7ffc3e3a3a84
    //指针变量 p 的值：0x7ffc3e3a3a84
    //指针 p 所指向的变量的值：10
  return 0;
}
```
变量 a 的地址：0x7ffc3e3a3a84
指针变量 p 的值：0x7ffc3e3a3a84
指针 p 所指向的变量的值：10

在上面的程序中，我们首先定义了一个整型变量a，并将其初始化为10。然后，我们定义了一个指向a的指针p，并使用地址运算符&获取了a的地址，并将其赋值给指针p。

接下来，我们使用printf()函数输出了a的地址、指针p的值以及指针p所指向的变量a的值。注意，在输出地址和指针值时，我们使用了%p格式化符号，它表示以十六进制输出指针或地址的值。

### malloc与new区别
malloc()和new都是在动态内存管理中使用的函数，它们都可以用来分配内存，但是它们之间有一些区别：

参数不同：malloc()需要指定要分配的内存块的大小，而new需要指定要分配的对象的类型。例如，分配一个int类型的内存块，可以使用malloc(sizeof(int))或new int。

返回值类型不同：malloc()返回一个void*类型的指针，而new返回一个分配的对象的指针。例如，int* p = new int返回一个int*类型的指针。

处理失败的方式不同：malloc()在内存不足时返回NULL指针，而new在内存不足时会抛出一个std::bad_alloc异常。

初始化不同：malloc()分配的内存未初始化，而new分配的内存会自动调用构造函数进行初始化。

释放内存方式不同：malloc()分配的内存需要使用free()函数手动释放，而new分配的内存需要使用delete操作符手动释放。需要注意的是，释放内存时需要与分配内存时使用的函数或操作符匹配。不能使用free()释放new分配的内存，也不能使用delete释放malloc()分配的内存。

在C++中，通常推荐使用new和delete来进行动态内存管理，因为它们提供了更好的类型安全和异常处理机制。在C语言中，只有malloc()和free()函数可用，因此需要手动进行内存管理，同时需要注意内存泄漏和指针错误等问题。

### static关键字有什么作用？
static是C++中的一个关键字，它可以用于不同的场景，有不同的作用。下面是static关键字的几种用法及其作用：

在函数中使用static关键字：当static关键字用于函数内部时，表示函数的作用域被限定在声明它的文件内部。这意味着，即使在其他文件中也可以定义具有相同名称的函数，而不会出现命名冲突。另外，函数内的static变量也具有相同的作用域和生命周期，可以在函数调用之间保留其值。

在类中使用static关键字：当static关键字用于类的成员变量时，表示该变量是一个类级别的变量，而不是对象级别的变量。这意味着，该变量的值对于所有对象来说都是相同的，并且可以通过类名和作用域解析符直接访问。另外，类中的静态成员变量必须在类外部定义和初始化。

在类中使用static关键字作为静态成员函数的前缀：当static关键字用于类的成员函数时，表示该函数是一个类级别的函数，而不是对象级别的函数。这意味着，该函数可以直接访问类的静态成员变量，但不能访问非静态成员变量。另外，静态成员函数没有this指针，因此不能访问对象级别的内容。

在全局变量中使用static关键字：当static关键字用于全局变量时，表示该变量的作用域被限定在声明它的文件内部。这意味着，即使在其他文件中也可以定义具有相同名称的变量，而不会出现命名冲突。另外，全局静态变量也具有相同的生命周期，可以在程序的整个执行过程中保留其值。

需要注意的是，static关键字的用法和作用在不同的场景下可能会有所不同，因此使用时需要根据具体的情况进行选择。
### #define和const有什么区别？
作用域不同：#define定义的常量没有作用域限制，可以在任何地方使用，而const定义的常量的作用域受限于定义的位置，只能在定义的作用域内使用。

类型检查不同：#define定义的常量没有类型检查，可以定义任何类型的常量，而const定义的常量会进行类型检查，保证只定义符合类型的常量。

存储方式不同：#define定义的常量只是进行简单的文本替换，不占用内存空间，而const定义的常量会在内存中分配空间。

调试不同：#define定义的常量在编译期间就已经被替换了，因此在程序调试时可能无法查看常量的值，而const定义的常量可以在调试期间进行查看和修改。

### 说一说extern“C”
C++代码调用C语言代码
在C++的头文件中使用
在多个人协同开发时，可能有的人比较擅长C语言，而有的人擅长C++，这样的情况下也会有用到

### 说说 static关键字的作用
定义全局静态变量和局部静态变量
定义静态函数
在c++中，static关键字可以用于定义类中的静态成员变量
在c++中，static关键字可以用于定义类中的静态成员函数